document.addEventListener('DOMContentLoaded', function() {
    let gameMode = '3peg';
    let diskCount = 0;
    let minMoves = 0;
    let yourMoves = 0;
    let moveHistory = [];
    let solutions = {};
    let gameInProgress = false;
    let draggingDisk = null;
    let draggedTower = null;
    let gameTimer = null;
    let gameSeconds = 0;
    let gameStartTime = null;

    const mode3PegBtn = document.getElementById('mode-3peg');
    const mode4PegBtn = document.getElementById('mode-4peg');
    const threePegTowers = document.getElementById('three-peg-towers');
    const fourPegTowers = document.getElementById('four-peg-towers');
    const diskCountEl = document.getElementById('disk-count');
    const minMovesEl = document.getElementById('min-moves');
    const yourMovesEl = document.getElementById('your-moves');
    const newGameBtn = document.getElementById('new-game');
    const showSolutionBtn = document.getElementById('show-solution');
    const submitSolutionBtn = document.getElementById('submit-solution');
    const toggleMoveHistoryBtn = document.getElementById('toggle-move-history');
    const solutionModal = document.getElementById('solution-modal');
    const successModal = document.getElementById('success-modal');
    const closeButtons = document.querySelectorAll('.close');
    const playAgainBtn = document.getElementById('play-again');
    const playerInputPanel = document.getElementById('player-input');
    const playerNameInput = document.getElementById('player-name');
    const saveScoreBtn = document.getElementById('save-score');
    const cancelSaveBtn = document.getElementById('cancel-save');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const solutionTabs = document.querySelectorAll('.solution-tab');
    const solutionPanels = document.querySelectorAll('.solution-panel');
    const minutesDisplay = document.getElementById('minutes');
    const secondsDisplay = document.getElementById('seconds');
    const moveHistoryList = document.getElementById('move-history-list');
    const moveHistoryPanel = document.getElementById('move-history');
    const diskSelector = document.getElementById('disk-selector');

    const diskColors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12',
        '#9b59b6', '#1abc9c', '#d35400', '#34495e',
        '#c0392b', '#2980b9'
    ];

    function initEventListeners() {
        mode3PegBtn.addEventListener('click', () => switchMode('3peg'));
        mode4PegBtn.addEventListener('click', () => switchMode('4peg'));
        newGameBtn.addEventListener('click', startNewGame);
        showSolutionBtn.addEventListener('click', showSolution);
        submitSolutionBtn.addEventListener('click', handleSubmitSolution);
        toggleMoveHistoryBtn.addEventListener('click', toggleMoveHistory);
        playAgainBtn.addEventListener('click', () => {
            hideModal(successModal);
            startNewGame();
        });
        saveScoreBtn.addEventListener('click', saveScore);
        cancelSaveBtn.addEventListener('click', () => {
            playerInputPanel.classList.add('hidden');
        });
        closeButtons.forEach(btn => {
            btn.addEventListener('click', function() {
                hideModal(this.closest('.modal'));
            });
        });
        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                switchTab(this.getAttribute('data-tab'));
            });
        });
        solutionTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                switchSolutionTab(this.getAttribute('data-solution'));
            });
        });
        diskSelector.addEventListener('change', function() {
            if (gameInProgress && confirm('Changing disk count will reset the game. Continue?')) {
                startNewGame();
            }
        });
    }

    function toggleMoveHistory() {
        moveHistoryPanel.classList.toggle('hidden');
    }

    function switchMode(mode) {
        if (gameInProgress && gameMode !== mode && !confirm('Changing modes will reset the game. Continue?')) {
            return;
        }
        gameMode = mode;
        mode3PegBtn.classList.toggle('active', mode === '3peg');
        mode4PegBtn.classList.toggle('active', mode === '4peg');
        threePegTowers.classList.toggle('hidden', mode !== '3peg');
        fourPegTowers.classList.toggle('hidden', mode === '3peg');
        if (gameInProgress) {
            startNewGame();
        }
    }

    async function startNewGame() {
        try {
            const selectedDisks = diskSelector.value;
            diskCount = selectedDisks === 'random' ? Math.floor(Math.random() * 6) + 5 : parseInt(selectedDisks);
            const response = await fetch(`/api/toh/new-game?disks=${diskCount}`);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to start new game');
            }
            const data = await response.json();

            diskCount = data.disk_count;
            minMoves = data.min_moves;
            yourMoves = 0;
            moveHistory = [];
            solutions = data.solutions || {};
            gameInProgress = true;

            moveHistoryList.innerHTML = '';
            moveHistoryPanel.classList.add('hidden');
            diskCountEl.textContent = diskCount;
            minMovesEl.textContent = minMoves;
            yourMovesEl.textContent = yourMoves;

            clearTowers();
            setupTowers();
            setupDragAndDrop();
            updateSolutionModal();
            startGameTimer();
        } catch (error) {
            console.error('Error starting new game:', error);
            alert(`Failed to start new game: ${error.message}. Please try again.`);
        }
    }

    function clearTowers() {
        const towers = gameMode === '3peg' ? 
            document.querySelectorAll('#three-peg-towers .tower') : 
            document.querySelectorAll('#four-peg-towers .tower');
        towers.forEach(tower => {
            tower.querySelectorAll('.disk').forEach(disk => disk.remove());
        });
    }

    function setupTowers() {
        const sourceTower = gameMode === '3peg' ? 
            document.getElementById('tower-A') : 
            document.getElementById('tower-A-4');
        const towers = gameMode === '3peg' ? 
            document.querySelectorAll('#three-peg-towers .tower') : 
            document.querySelectorAll('#four-peg-towers .tower');

        for (let i = diskCount; i > 0; i--) {
            const disk = document.createElement('div');
            disk.className = 'disk';
            disk.dataset.size = i;
            const maxWidth = sourceTower.querySelector('.base').offsetWidth * 0.9;
            const minWidth = maxWidth * 0.3;
            const width = minWidth + ((maxWidth - minWidth) * (i / diskCount));
            disk.style.width = `${width}px`;
            disk.style.backgroundColor = diskColors[(i - 1) % diskColors.length];
            disk.textContent = i;
            sourceTower.insertBefore(disk, sourceTower.querySelector('.peg').nextSibling);
        }
    }

    function setupDragAndDrop() {
        const disks = document.querySelectorAll('.disk');
        const towers = gameMode === '3peg' ? 
            document.querySelectorAll('#three-peg-towers .tower') : 
            document.querySelectorAll('#four-peg-towers .tower');

        // Named functions for event listeners to allow removal
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            if (!draggingDisk || this === draggedTower) return;
            const targetTower = this;
            const diskSize = parseInt(draggingDisk.dataset.size);
            const topDiskOnTarget = getTopDisk(targetTower);
            if (topDiskOnTarget && parseInt(topDiskOnTarget.dataset.size) < diskSize) {
                alert('Cannot place a larger disk on a smaller one.');
                return;
            }

            const sourceId = draggedTower.id.includes('-4') ? 
                draggedTower.id.charAt(draggedTower.id.length - 1) : 
                draggedTower.id.charAt(draggedTower.id.length - 1);
            const targetId = targetTower.id.includes('-4') ? 
                targetTower.id.charAt(targetTower.id.length - 1) : 
                targetTower.id.charAt(targetTower.id.length - 1);

            targetTower.insertBefore(draggingDisk, targetTower.querySelector('.peg').nextSibling);
            draggingDisk.classList.add('animate-move');
            setTimeout(() => draggingDisk.classList.remove('animate-move'), 500);

            yourMoves++;
            yourMovesEl.textContent = yourMoves;
            moveHistory.push([diskSize, sourceId, targetId]);

            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.textContent = `${yourMoves}. Move disk ${diskSize} from ${sourceId} to ${targetId}`;
            moveHistoryList.appendChild(moveItem);
            moveHistoryPanel.classList.remove('hidden');
            moveHistoryList.scrollTop = moveHistoryList.scrollHeight;

            checkWinCondition();
        }

        // Remove existing listeners to prevent duplicates
        towers.forEach(tower => {
            tower.removeEventListener('dragover', handleDragOver);
            tower.removeEventListener('drop', handleDrop);
            tower.addEventListener('dragover', handleDragOver);
            tower.addEventListener('drop', handleDrop);
        });

        disks.forEach(disk => {
            disk.setAttribute('draggable', true);
            disk.addEventListener('dragstart', function(e) {
                const tower = this.parentElement;
                const topDisk = getTopDisk(tower);
                if (this !== topDisk) {
                    e.preventDefault();
                    return;
                }
                draggingDisk = this;
                draggedTower = tower;
                this.classList.add('dragging');
                e.dataTransfer.setData('text/plain', this.dataset.size);
            });
            disk.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                draggingDisk = null;
            });
        });
    }

    function getTopDisk(tower) {
        const disks = Array.from(tower.querySelectorAll('.disk'));
        return disks.length > 0 ? disks[0] : null;
    }

    function checkWinCondition() {
        const destinationTower = gameMode === '3peg' ? 
            document.getElementById('tower-C') : 
            document.getElementById('tower-D-4');
        const disks = Array.from(destinationTower.querySelectorAll('.disk'));

        if (disks.length === diskCount) {
            const sizes = disks.map(disk => parseInt(disk.dataset.size));
            const isValid = sizes.every((size, i) => i === 0 || size < sizes[i-1]);
            if (!isValid) return;

            gameInProgress = false;
            stopGameTimer();

            const totalScore = Math.floor((minMoves / yourMoves) * 1000);
            document.getElementById('success-message').innerHTML = `
                <p>Congratulations! You solved it in ${yourMoves} moves (Minimum: ${minMoves}).</p>
                <p>Time: ${Math.floor(gameSeconds / 60)}:${(gameSeconds % 60).toString().padStart(2, '0')}</p>
                <p>Score: ${totalScore} points</p>
            `;

            showModal(successModal);
            playerInputPanel.classList.remove('hidden');
        }
    }

    function showSolution() {
        if (!gameInProgress) {
            alert('Please start a new game to view solutions.');
            return;
        }
        updateSolutionModal();
        showModal(solutionModal);
    }

    function updateSolutionModal() {
        const solutionsData = [
            { id: 'recursive', name: 'Recursive (3-peg)', moves: solutions.recursive?.moves || [], time: solutions.recursive?.time || 0 },
            { id: 'iterative', name: 'Iterative (3-peg)', moves: solutions.iterative?.moves || [], time: solutions.iterative?.time || 0 },
            { id: 'frame_stewart', name: 'Frame-Stewart (4-peg)', moves: solutions.frame_stewart?.moves || [], time: solutions.frame_stewart?.time || 0 }
        ];

        solutionsData.forEach(({ id, name, moves, time }) => {
            const panel = document.getElementById(`${id}-solution`);
            const timeEl = document.getElementById(`${id}-time`);
            const movesEl = document.getElementById(`${id}-moves`);

            if (!panel || !timeEl || !movesEl) {
                console.error(`Solution panel elements missing for ${id}`);
                return;
            }

            timeEl.textContent = (time * 1000).toFixed(4);
            movesEl.innerHTML = '';

            if (moves.length === 0) {
                const errorItem = document.createElement('div');
                errorItem.className = 'move-item';
                errorItem.textContent = `No moves available for ${name}.`;
                movesEl.appendChild(errorItem);
            } else {
                moves.forEach((move, index) => {
                    const [disk, source, dest] = move;
                    const moveItem = document.createElement('div');
                    moveItem.className = 'move-item';
                    moveItem.textContent = `${index + 1}. Move disk ${disk} from ${source} to ${dest}`;
                    movesEl.appendChild(moveItem);
                });
            }
        });
    }

    async function handleSubmitSolution() {
        if (!gameInProgress) {
            alert('Please start a new game to submit a solution.');
            return;
        }
        const moveCount = prompt('Enter the number of moves:');
        if (!moveCount || isNaN(moveCount) || moveCount < 1) {
            alert('Please enter a valid number of moves.');
            return;
        }
        const movesInput = prompt('Enter your move sequence (e.g., "1 A to C, 2 A to B, ..."):');
        if (!movesInput) {
            alert('Please enter a move sequence.');
            return;
        }
        const moves = movesInput.split(',').map(m => {
            const parts = m.trim().split(' ');
            const disk = parseInt(parts[0]);
            const source = parts[1];
            const dest = parts[3];
            return [disk, source, dest];
        }).filter(move => move[0] && move[1] && move[2]);

        if (moves.length != moveCount) {
            alert('Move count does not match the number of moves entered.');
            return;
        }

        try {
            const response = await fetch('/api/toh/validate-solution', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ playerName: 'Anonymous', diskCount, moves })
            });
            const data = await response.json();
            if (data.success) {
                yourMoves = moves.length;
                moveHistory = moves;
                yourMovesEl.textContent = yourMoves;
                moveHistoryList.innerHTML = '';
                moves.forEach((move, i) => {
                    const [disk, source, dest] = move;
                    const moveItem = document.createElement('div');
                    moveItem.className = 'move-item';
                    moveItem.textContent = `${i + 1}. Move disk ${disk} from ${source} to ${dest}`;
                    moveHistoryList.appendChild(moveItem);
                });
                checkWinCondition();
            } else {
                alert(data.message);
            }
        } catch (error) {
            console.error('Error validating solution:', error);
            alert('Failed to validate solution. Please try again.');
        }
    }

    async function saveScore() {
        const playerName = playerNameInput.value.trim() || 'Anonymous';
        try {
            const response = await fetch('/api/toh/validate-solution', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ playerName, diskCount, moves: moveHistory })
            });
            const data = await response.json();
            if (data.success) {
                playerInputPanel.classList.add('hidden');
                loadScores();
                switchTab('scores');
            } else {
                alert(data.message);
            }
        } catch (error) {
            console.error('Error saving score:', error);
            alert('Failed to save score. Please try again.');
        }
    }

    async function loadScores() {
        try {
            const response = await fetch('/api/toh/scores');
            const scores = await response.json();
            const scoresBody = document.getElementById('scores-body');
            scoresBody.innerHTML = '';
            scores.forEach(score => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${score.player_name}</td>
                    <td>${score.disk_count}</td>
                    <td>${score.moves_count}</td>
                `;
                scoresBody.appendChild(row);
            });
        } catch (error) {
            console.error('Error loading scores:', error);
        }
    }

    async function loadAlgorithmComparison() {
        try {
            const response = await fetch('/api/toh/algorithm-comparison');
            const data = await response.json();
            const algorithmBody = document.getElementById('algorithm-body');
            algorithmBody.innerHTML = '';
            data.forEach(item => {
                const row = document.createElement('tr');
                const algorithmName = {
                    'recursive': 'Recursive',
                    'iterative': 'Iterative',
                    'frame_stewart': 'Frame-Stewart'
                }[item.algorithm_type] || 'Unknown';
                row.innerHTML = `
                    <td>${item.disk_count}</td>
                    <td>${algorithmName}</td>
                    <td>${item.peg_count}</td>
                    <td>${(item.avg_time * 1000).toFixed(4)}</td>
                `;
                algorithmBody.appendChild(row);
            });
        } catch (error) {
            console.error('Error loading algorithm comparison:', error);
        }
    }

    function switchTab(tabId) {
        tabs.forEach(tab => tab.classList.toggle('active', tab.getAttribute('data-tab') === tabId));
        tabContents.forEach(content => content.classList.toggle('active', content.id === `${tabId}-content`));
        if (tabId === 'scores') loadScores();
        else if (tabId === 'algorithms') loadAlgorithmComparison();
    }

    function switchSolutionTab(solutionId) {
        solutionTabs.forEach(tab => tab.classList.toggle('active', tab.getAttribute('data-solution') === solutionId));
        solutionPanels.forEach(panel => panel.classList.toggle('active', panel.id === `${solutionId}-solution`));
    }

    function showModal(modal) {
        modal.classList.remove('hidden');
        modal.classList.add('show');
    }

    function hideModal(modal) {
        modal.classList.remove('show');
        modal.classList.add('hidden');
    }

    function startGameTimer() {
        gameSeconds = 0;
        updateTimerDisplay();
        if (gameTimer) clearInterval(gameTimer);
        gameStartTime = Date.now();
        gameTimer = setInterval(() => {
            gameSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
            updateTimerDisplay();
        }, 1000);
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(gameSeconds / 60);
        const seconds = gameSeconds % 60;
        minutesDisplay.textContent = minutes.toString().padStart(2, '0');
        secondsDisplay.textContent = seconds.toString().padStart(2, '0');
    }

    function stopGameTimer() {
        if (gameTimer) {
            clearInterval(gameTimer);
            gameTimer = null;
        }
    }

    function initGame() {
        initEventListeners();
        switchTab('instructions');
        startNewGame();
    }

    initGame();
});